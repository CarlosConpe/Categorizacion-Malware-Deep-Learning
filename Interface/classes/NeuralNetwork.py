from classes.MachineLearningModel import *
import tensorflow as tf
import time
import numpy as np


class NeuralNetwork(MachineLearningModel):
  #Not inherited: Method to build neural network based on architecture specifications
  def build(self):
    layer_array = []
    #We attach our input layer into our layer array:
    layer_array.append(tf.keras.layers.Flatten(input_shape = self.network_architecture['input_size']))
    #We attach our hidden layers into our layer array:
    for layer in self.network_architecture['architecture']:
      layer_array.append(tf.keras.layers.Dense(layer, activation = "relu"))
    #We attach our output layer into our layer array
    layer_array.append(tf.keras.layers.Dense(self.network_architecture['output_size'], activation = "sigmoid"))
    #We create a neural network model using the layer array specifications. self.model is our actual network
    self.model = tf.keras.Sequential(layer_array)

  #Constructor:
  def __init__(self, *, architecture, input_size, output_size, epochs, name, verbose):
    #We inherit from the machine learning model class:
    super(NeuralNetwork, self).__init__(model_name = name, verbose = verbose)
    #We create a dictionary/hash map with the properties of our neural network
    self.network_architecture = {'architecture': architecture, 
                                 'input_size': input_size, 
                                 'output_size': output_size, 
                                 'epochs': epochs}
    #We build our neural network based on the specifications
    self.build()

  #We compile the built neural network
  def compile(self):
    our_optimizer = 'adam'
    our_metric = 'accuracy'
    self.model.compile(optimizer = our_optimizer, loss = tf.keras.losses.BinaryCrossentropy(from_logits = False), metrics = [our_metric])
  
  #We train our neural network with a given dataset
  def train(self, *, training_data, training_labels):
    self.model.fit(training_data, training_labels, validation_split = 0.3, epochs = self.network_architecture['epochs'], shuffle = True)
    
  #We check how accurate our neural network is
  def evaluate(self, samples):
    #We grab the testing data so we can run our test
    testing_labels = samples['testing_labels']
    testing_data = samples['testing_data']

    #We build a probability model that will predict our testing data
    probability_model = tf.keras.Sequential([self.model, tf.keras.layers.Softmax()])
    predictions = probability_model.predict(testing_data)

    scores = self.model.evaluate(testing_data,testing_labels)
    print("Total tests: ", len(testing_labels))
    #We check how many correct guesses the neural network made
    self.loss = scores[0]
    self.accuracy = scores[1]