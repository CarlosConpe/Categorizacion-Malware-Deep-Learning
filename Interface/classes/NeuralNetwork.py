from classes.MachineLearningModel import *
import tensorflow as tf
import time
import numpy as np


class NeuralNetwork(MachineLearningModel):
    # Not inherited: Method to build neural network based on architecture specifications
    def build(self):
        layer_array = []
        # We attach our input layer into our layer array:
        layer_array.append(
            tf.keras.layers.Flatten(input_shape=self.network_architecture["input_size"])
        )
        # We attach our hidden layers into our layer array:
        for layer in self.network_architecture["architecture"]:
            layer_array.append(tf.keras.layers.Dense(layer, activation="relu"))
        # We attach our output layer into our layer array
        layer_array.append(
            tf.keras.layers.Dense(self.network_architecture["output_size"])
        )
        # We create a neural network model using the layer array specifications. self.model is our actual network
        self.model = tf.keras.Sequential(layer_array)

    # Constructor:
    def __init__(self, *, architecture, input_size, output_size, epochs, name, verbose):
        # We inherit from the machine learning model class:
        super(NeuralNetwork, self).__init__(model_name=name, verbose=verbose)
        # We create a dictionary/hash map with the properties of our neural network
        self.network_architecture = {
            "architecture": architecture,
            "input_size": input_size,
            "output_size": output_size,
            "epochs": epochs,
        }
        # We build our neural network based on the specifications
        self.build()

    # We compile the built neural network
    def compile(self):
        our_optimizer = "adam"
        our_metric = "accuracy"
        self.model.compile(
            optimizer=our_optimizer,
            loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
            metrics=[our_metric],
        )

    # We train our neural network with a given dataset
    def train(self, *, training_data, training_labels):
        start = time.time()
        self.model.fit(
            training_data, training_labels, epochs=self.network_architecture["epochs"]
        )
        end = time.time()
        self.training_time = end - start

    # We check how accurate our neural network is
    def evaluate(self, samples):
        # We grab the testing data so we can run our test
        start = time.time()

        testing_labels = samples["testing_labels"]
        testing_data = samples["testing_data"]

        # We build a probability model that will predict our testing data
        probability_model = tf.keras.Sequential([self.model, tf.keras.layers.Softmax()])
        predictions = probability_model.predict(testing_data, verbose=0)

        # We check how many correct guesses the neural network made
        correct_guesses = 0
        for i in range(0, len(testing_labels)):
            if testing_labels[i] == np.argmax(
                probability_model.predict(np.expand_dims(testing_data[i], 0), verbose=0)
            ):
                correct_guesses += 1
        self.accuracy = correct_guesses / len(testing_data)

        end = time.time()
        self.evaluation_time = end - start
