from classes.MachineLearningModel import *

from sklearn.model_selection import RepeatedKFold
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
import pandas as pd
import multiprocessing


class GradientBoostingMachine(MachineLearningModel):
    # Constructor
    def __init__(self, name, verbose):
        super(GradientBoostingMachine, self).__init__(model_name=name, verbose=verbose)

    def build(
        self,
        n_estimators=[50, 100, 500, 1000],
        max_features=["auto", "sqrt", "log2"],
        max_depth=[None, 1, 3, 5, 10, 20],
        subsample=[0.5, 1],
        learning_rate=[0.001, 0.01, 0.1],
    ):
        self.param_grid = {
            "n_estimators": n_estimators,
            "max_features": max_features,
            "max_depth": max_depth,
            "subsample": subsample,
            "learning_rate": learning_rate,
        }

        self.grid = GridSearchCV(
            estimator=GradientBoostingClassifier(random_state=123),
            param_grid=self.param_grid,
            scoring="accuracy",
            n_jobs=multiprocessing.cpu_count() - 1,
            cv=RepeatedKFold(n_splits=3, n_repeats=1, random_state=123),
            refit=True,
            verbose=self.verbose,
            return_train_score=True,
        )

    # We compile the Gradient Boosting Machine
    def compile(self):
        self.build()

    def train(self, training_data, training_labels):
        self.grid.fit(X=training_data, y=training_labels)
        # Resultados
        # ==============================================================================
        resultados = pd.DataFrame(self.grid.cv_results_)
        resultados.filter(regex="(param*|mean_t|std_t)").drop(
            columns="params"
        ).sort_values("mean_test_score", ascending=False).head(4)

        self.modelo_final = self.grid.best_estimator_

    def evaluate(self, samples):
        # Error de test del modelo final
        # ==============================================================================
        y_test = samples["testing_labels"]
        x_test = samples["testing_data"]

        self.predicciones = self.modelo_final.predict(X=x_test)
        # self.predicciones[:10]

        self.mat_confusion = confusion_matrix(y_true=y_test, y_pred=self.predicciones)

        self.accuracy = accuracy_score(
            y_true=y_test, y_pred=self.predicciones, normalize=True
        )
